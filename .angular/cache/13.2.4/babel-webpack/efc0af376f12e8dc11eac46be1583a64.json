{"ast":null,"code":"import _asyncToGenerator from \"/home/administrador/angular/dominga-panel/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { BehaviorSubject, from } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/fire/compat/firestore\";\nimport * as i2 from \"../../shared/services/local-storage.service\";\nexport class ArtistasService {\n  constructor(afs, ls) {\n    this.afs = afs;\n    this.ls = ls;\n    this.artistas = []; //copia activa local de todos los lugares para trabajar con ella\n\n    this.idNuevoArtista = '';\n    this.artistasRef = this.afs.collection('artistas');\n    this.mapCache = new Map();\n    this.artistas$ = new BehaviorSubject(this.artistas);\n  }\n  /**\n   * Obtiene todos los artistas desde firestore y los almacena en artistas[] para\n   * no estar consultado la base y minimizar el traficio.\n   */\n\n\n  getArtistasFirestore(dpto) {\n    if (!this.mapCache.has(dpto)) {\n      console.log(\"get artistas \" + dpto + \" desde firestore\"); //this.afs.collection('artistas').ref.where('departamento', \"==\", dpto).where('fechaFin', \">=\", Timestamp.fromDate(fechaActual) ).orderBy('fechaFin').get().then(\n\n      this.artistasRef.ref.where('departamento', \"==\", dpto).get().then(querySnapshot => {\n        let arrArtista = [];\n        querySnapshot.forEach(item => {\n          const data = item.data();\n          arrArtista.push(Object.assign({\n            id: item.id\n          }, data));\n        });\n        this.mapCache.set(dpto, arrArtista.slice());\n        this.artistas = arrArtista.slice(); //this.artistas$.next(this.artistas); //el subject lugares$ emite los lugares\n\n        this.getArtistasFiltrados();\n      }).catch(error => {\n        console.error(\"Error en getArtistasFirestore(). error:\" + error);\n      });\n    } else {\n      console.log(\"get artistas \" + dpto + \" desde la cache de lugares\");\n      let arrArtistas = [];\n      arrArtistas = this.mapCache.get(dpto);\n      this.artistas = arrArtistas.slice();\n      this.getArtistasFiltrados(); //this.artistas$.next(this.artistas)\n    }\n  }\n\n  getArtistasFiltrados() {\n    // Por departamento\n    if (this.ls.localidad === '' && this.ls.publicado === 'todos') {\n      this.artistas$.next(this.artistas);\n    } // Departamento y Publidados\n    else if (this.ls.localidad === '' && this.ls.publicado !== 'todos') {\n      let p = this.ls.publicado === 'publicados' ? true : false;\n      this.artistas$.next(this.artistas.filter(artista => artista.publicado == p));\n    } // Departamento y Localidad \n    else if (this.ls.localidad !== '' && this.ls.publicado === 'todos') {\n      this.artistas$.next(this.artistas.filter(artista => artista.localidad === this.ls.localidad));\n    } // Departamento, Localidad y Publidados\n    else if (this.ls.localidad !== '' && this.ls.publicado !== 'todos') {\n      let p = this.ls.publicado === 'publicados' ? true : false;\n      this.artistas$.next(this.artistas.filter(artista => artista.localidad === this.ls.localidad && artista.publicado == p));\n    }\n  }\n  /** Obtiene el artista a partir del id que recibe y */\n\n\n  getArtistaId(id) {\n    const eventoEncontrado = this.artistas.filter(item => item.id == id);\n    return from(eventoEncontrado);\n  }\n  /**\n   * Agrega un artista en firestore, obteniendo el id resultante para luego insertarlo en el\n   * array local artistas.\n   * @param artista Contiene la información del nuevo artista.\n   * @returns Retorna el ID del artista obtenido de firestore\n   */\n\n\n  addArtista(artista) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      let nuevoId;\n\n      try {\n        const documentRef = yield _this.artistasRef.add(artista);\n        nuevoId = documentRef.id;\n        artista.id = nuevoId;\n\n        _this.artistas.push(artista);\n\n        _this.mapCache.set(artista.departamento, _this.artistas);\n      } catch (error) {\n        console.error(\"Se produjo un error al agregar un nuevo artista. Error: \" + error);\n      }\n\n      return new Promise((resolve, reject) => {\n        if (nuevoId !== undefined && nuevoId.length > 0) {\n          resolve(nuevoId);\n        } else {\n          reject(\"No se puedo obtener el ID\");\n        }\n      });\n    })();\n  }\n  /**\n   * Actuliza la información de lugar en la nube de Firestore, utilizando el método destructivo \"set\" (borra todo lo que este y\n   * guarda solo los valores actuales).\n   * @param lugar Contiene todos los datos del lugar menos el ID.\n   * @returns\n   */\n\n\n  updateArtistaFirestore(artista, id) {\n    return this.afs.doc(`artistas/${id}`).set(artista); //en ves de pasar el lugar completo se puede poner campo por campo        \n  }\n  /**\n   * Actualiza la información de un lugar ya existente en el array local lugares.\n   * @param data Es la data con toda la información del lugar includio el ID\n   */\n\n\n  updateArtistaLocal(data) {\n    let i = this.artistas.findIndex(artista => artista.id === data.id);\n    this.artistas[i] = JSON.parse(JSON.stringify(data));\n    this.mapCache.set(data.departamento, this.artistas);\n  }\n\n  getCache(nombreDpto) {\n    return this.mapCache.get(nombreDpto);\n  }\n  /**\n   * Obtiene el observable del Subject artistas$ con la lista de todos los artistas.\n   * @returns {Observable}\n   */\n\n\n  getObsArtistas$() {\n    return this.artistas$.asObservable();\n  }\n\n  emitirArtistas() {\n    this.artistas$.next(this.artistas);\n  }\n  /** Elimina correctamente el artista */\n\n\n  deleteArtista(id) {\n    let indiceEliminar = this.artistas.findIndex(item => item.id === id);\n    this.artistasRef.doc(id).delete().then(res => {\n      this.artistas.splice(indiceEliminar, 1);\n      this.emitirArtistas();\n      console.log(\"Artista eliminado correntamente\");\n    }).catch(err => {\n      console.error(\"Se produjo un error al intentar eliminar un el artista \" + id + \". Error:\" + err);\n    });\n  }\n  /**\n   * test Ok: Filtra lugares por departamento en el array local lugares. La lista\n   * resultante es emitida desde el Subject lugares$.\n   * @param {String} departamento Nombre del departamento por el cual se realiza la busqueda.\n   */\n\n\n  getArtistasPorDepartamento(departamento) {\n    let eventosDepartamento = this.artistas.filter(artista => artista.departamento === departamento);\n    this.artistas$.next(eventosDepartamento);\n  }\n  /** OK: Filtra por el estado de publicacion y por el departamento, luego\n   * actualiza el Subject  lugares$\n    */\n\n\n  getArtistasPublicadoYDepartamento(pub, depto) {\n    this.artistas$.next(this.artistas.filter(artista => {\n      if (artista.publicado === pub && artista.departamento === depto) {\n        return true;\n      } else {\n        return false;\n      }\n    }));\n  }\n\n  getArtistasPublicadoDepartamentoLocalidad(pub, dpto, loc) {\n    this.artistas$.next(this.artistas.filter(artista => {\n      if (artista.publicado === pub && artista.departamento === dpto && artista.localidad === loc) {\n        return true;\n      } else {\n        return false;\n      }\n    }));\n  }\n\n  getArtistasLocalidad(loc) {\n    let eventosLocalidad = this.artistas.filter(artista => artista.localidad === loc);\n    this.artistas$.next(eventosLocalidad);\n  }\n  /**\n   *  Función para generar string random, se utilizar para crear el nombre de la carpeta\n   * que almacena las imagenes. Funciona como un id.\n   * @param length Es largo que queremos el string.\n   * @returns Retorna un string random.\n   */\n\n\n  randomString(length) {\n    var randomChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    var result = '';\n\n    for (var i = 0; i < length; i++) {\n      result += randomChars.charAt(Math.floor(Math.random() * randomChars.length));\n    }\n\n    return result;\n  }\n\n}\n\nArtistasService.ɵfac = function ArtistasService_Factory(t) {\n  return new (t || ArtistasService)(i0.ɵɵinject(i1.AngularFirestore), i0.ɵɵinject(i2.LocalStorageService));\n};\n\nArtistasService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: ArtistasService,\n  factory: ArtistasService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"sources":["/home/administrador/angular/dominga-panel/src/app/artistas/services/artistas.service.ts"],"names":["BehaviorSubject","from","i0","i1","i2","ArtistasService","constructor","afs","ls","artistas","idNuevoArtista","artistasRef","collection","mapCache","Map","artistas$","getArtistasFirestore","dpto","has","console","log","ref","where","get","then","querySnapshot","arrArtista","forEach","item","data","push","Object","assign","id","set","slice","getArtistasFiltrados","catch","error","arrArtistas","localidad","publicado","next","p","filter","artista","getArtistaId","eventoEncontrado","addArtista","nuevoId","documentRef","add","departamento","Promise","resolve","reject","undefined","length","updateArtistaFirestore","doc","updateArtistaLocal","i","findIndex","JSON","parse","stringify","getCache","nombreDpto","getObsArtistas$","asObservable","emitirArtistas","deleteArtista","indiceEliminar","delete","res","splice","err","getArtistasPorDepartamento","eventosDepartamento","getArtistasPublicadoYDepartamento","pub","depto","getArtistasPublicadoDepartamentoLocalidad","loc","getArtistasLocalidad","eventosLocalidad","randomString","randomChars","result","charAt","Math","floor","random","ɵfac","ArtistasService_Factory","t","ɵɵinject","AngularFirestore","LocalStorageService","ɵprov","ɵɵdefineInjectable","token","factory","providedIn"],"mappings":"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","sourcesContent":["import { BehaviorSubject, from } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/fire/compat/firestore\";\nimport * as i2 from \"../../shared/services/local-storage.service\";\nexport class ArtistasService {\n    constructor(afs, ls) {\n        this.afs = afs;\n        this.ls = ls;\n        this.artistas = []; //copia activa local de todos los lugares para trabajar con ella\n        this.idNuevoArtista = '';\n        this.artistasRef = this.afs.collection('artistas');\n        this.mapCache = new Map();\n        this.artistas$ = new BehaviorSubject(this.artistas);\n    }\n    /**\n     * Obtiene todos los artistas desde firestore y los almacena en artistas[] para\n     * no estar consultado la base y minimizar el traficio.\n     */\n    getArtistasFirestore(dpto) {\n        if (!this.mapCache.has(dpto)) {\n            console.log(\"get artistas \" + dpto + \" desde firestore\");\n            //this.afs.collection('artistas').ref.where('departamento', \"==\", dpto).where('fechaFin', \">=\", Timestamp.fromDate(fechaActual) ).orderBy('fechaFin').get().then(\n            this.artistasRef.ref.where('departamento', \"==\", dpto).get().then(querySnapshot => {\n                let arrArtista = [];\n                querySnapshot.forEach(item => {\n                    const data = item.data();\n                    arrArtista.push(Object.assign({ id: item.id }, data));\n                });\n                this.mapCache.set(dpto, arrArtista.slice());\n                this.artistas = arrArtista.slice();\n                //this.artistas$.next(this.artistas); //el subject lugares$ emite los lugares\n                this.getArtistasFiltrados();\n            }).catch(error => {\n                console.error(\"Error en getArtistasFirestore(). error:\" + error);\n            });\n        }\n        else {\n            console.log(\"get artistas \" + dpto + \" desde la cache de lugares\");\n            let arrArtistas = [];\n            arrArtistas = this.mapCache.get(dpto);\n            this.artistas = arrArtistas.slice();\n            this.getArtistasFiltrados();\n            //this.artistas$.next(this.artistas)\n        }\n    }\n    getArtistasFiltrados() {\n        // Por departamento\n        if (this.ls.localidad === '' && this.ls.publicado === 'todos') {\n            this.artistas$.next(this.artistas);\n        }\n        // Departamento y Publidados\n        else if (this.ls.localidad === '' && this.ls.publicado !== 'todos') {\n            let p = this.ls.publicado === 'publicados' ? true : false;\n            this.artistas$.next(this.artistas.filter(artista => artista.publicado == p));\n        }\n        // Departamento y Localidad \n        else if (this.ls.localidad !== '' && this.ls.publicado === 'todos') {\n            this.artistas$.next(this.artistas.filter(artista => artista.localidad === this.ls.localidad));\n        }\n        // Departamento, Localidad y Publidados\n        else if (this.ls.localidad !== '' && this.ls.publicado !== 'todos') {\n            let p = this.ls.publicado === 'publicados' ? true : false;\n            this.artistas$.next(this.artistas.filter(artista => artista.localidad === this.ls.localidad && artista.publicado == p));\n        }\n    }\n    /** Obtiene el artista a partir del id que recibe y */\n    getArtistaId(id) {\n        const eventoEncontrado = this.artistas.filter(item => item.id == id);\n        return from(eventoEncontrado);\n    }\n    /**\n     * Agrega un artista en firestore, obteniendo el id resultante para luego insertarlo en el\n     * array local artistas.\n     * @param artista Contiene la información del nuevo artista.\n     * @returns Retorna el ID del artista obtenido de firestore\n     */\n    async addArtista(artista) {\n        let nuevoId;\n        try {\n            const documentRef = await this.artistasRef.add(artista);\n            nuevoId = documentRef.id;\n            artista.id = nuevoId;\n            this.artistas.push(artista);\n            this.mapCache.set(artista.departamento, this.artistas);\n        }\n        catch (error) {\n            console.error(\"Se produjo un error al agregar un nuevo artista. Error: \" + error);\n        }\n        return new Promise((resolve, reject) => {\n            if (nuevoId !== undefined && nuevoId.length > 0) {\n                resolve(nuevoId);\n            }\n            else {\n                reject(\"No se puedo obtener el ID\");\n            }\n        });\n    }\n    /**\n     * Actuliza la información de lugar en la nube de Firestore, utilizando el método destructivo \"set\" (borra todo lo que este y\n     * guarda solo los valores actuales).\n     * @param lugar Contiene todos los datos del lugar menos el ID.\n     * @returns\n     */\n    updateArtistaFirestore(artista, id) {\n        return this.afs.doc(`artistas/${id}`).set(artista); //en ves de pasar el lugar completo se puede poner campo por campo        \n    }\n    /**\n     * Actualiza la información de un lugar ya existente en el array local lugares.\n     * @param data Es la data con toda la información del lugar includio el ID\n     */\n    updateArtistaLocal(data) {\n        let i = this.artistas.findIndex(artista => artista.id === data.id);\n        this.artistas[i] = JSON.parse(JSON.stringify(data));\n        this.mapCache.set(data.departamento, this.artistas);\n    }\n    getCache(nombreDpto) {\n        return this.mapCache.get(nombreDpto);\n    }\n    /**\n     * Obtiene el observable del Subject artistas$ con la lista de todos los artistas.\n     * @returns {Observable}\n     */\n    getObsArtistas$() {\n        return this.artistas$.asObservable();\n    }\n    emitirArtistas() {\n        this.artistas$.next(this.artistas);\n    }\n    /** Elimina correctamente el artista */\n    deleteArtista(id) {\n        let indiceEliminar = this.artistas.findIndex(item => item.id === id);\n        this.artistasRef.doc(id).delete().then(res => {\n            this.artistas.splice(indiceEliminar, 1);\n            this.emitirArtistas();\n            console.log(\"Artista eliminado correntamente\");\n        }).catch(err => {\n            console.error(\"Se produjo un error al intentar eliminar un el artista \" + id + \". Error:\" + err);\n        });\n    }\n    /**\n     * test Ok: Filtra lugares por departamento en el array local lugares. La lista\n     * resultante es emitida desde el Subject lugares$.\n     * @param {String} departamento Nombre del departamento por el cual se realiza la busqueda.\n     */\n    getArtistasPorDepartamento(departamento) {\n        let eventosDepartamento = this.artistas.filter(artista => artista.departamento === departamento);\n        this.artistas$.next(eventosDepartamento);\n    }\n    /** OK: Filtra por el estado de publicacion y por el departamento, luego\n     * actualiza el Subject  lugares$\n      */\n    getArtistasPublicadoYDepartamento(pub, depto) {\n        this.artistas$.next(this.artistas.filter(artista => {\n            if (artista.publicado === pub && artista.departamento === depto) {\n                return true;\n            }\n            else {\n                return false;\n            }\n        }));\n    }\n    getArtistasPublicadoDepartamentoLocalidad(pub, dpto, loc) {\n        this.artistas$.next(this.artistas.filter(artista => {\n            if (artista.publicado === pub && artista.departamento === dpto && artista.localidad === loc) {\n                return true;\n            }\n            else {\n                return false;\n            }\n        }));\n    }\n    getArtistasLocalidad(loc) {\n        let eventosLocalidad = this.artistas.filter(artista => artista.localidad === loc);\n        this.artistas$.next(eventosLocalidad);\n    }\n    /**\n     *  Función para generar string random, se utilizar para crear el nombre de la carpeta\n     * que almacena las imagenes. Funciona como un id.\n     * @param length Es largo que queremos el string.\n     * @returns Retorna un string random.\n     */\n    randomString(length) {\n        var randomChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n        var result = '';\n        for (var i = 0; i < length; i++) {\n            result += randomChars.charAt(Math.floor(Math.random() * randomChars.length));\n        }\n        return result;\n    }\n}\nArtistasService.ɵfac = function ArtistasService_Factory(t) { return new (t || ArtistasService)(i0.ɵɵinject(i1.AngularFirestore), i0.ɵɵinject(i2.LocalStorageService)); };\nArtistasService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: ArtistasService, factory: ArtistasService.ɵfac, providedIn: 'root' });\n"]},"metadata":{},"sourceType":"module"}
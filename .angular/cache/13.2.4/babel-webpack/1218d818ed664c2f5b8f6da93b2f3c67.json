{"ast":null,"code":"import _asyncToGenerator from \"/home/administrador/angular/dominga-panel/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { BehaviorSubject, from } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/fire/compat/firestore\";\nimport * as i2 from \"../../shared/services/local-storage.service\";\nexport class DondeComerService {\n  constructor(afs, ls) {\n    this.afs = afs;\n    this.ls = ls;\n    this.restaurantes = []; //copia local de todos los restaurantes para trabajar con ella\n\n    this.mapCache = new Map();\n    this.departamento = \"San José\";\n    this.restaurantes$ = new BehaviorSubject(this.restaurantes);\n  }\n  /**\n   * Obtiene todos los restaurantes desde firestore y los almacena en restaurantes[] para\n   * no estar consultado la base y minimizar el traficio.\n   */\n\n\n  getRestaurantesFirestore(dpto) {\n    if (!this.mapCache.has(dpto) || this.restaurantes.length === 0) {\n      console.log(\"get restaurantes \" + dpto + \" desde firestore\"); //        this.afs.collection('eventos').ref.where('departamento', \"==\", departament).where('prioridad', \">\", -1).orderBy('prioridad').get().then(\n\n      this.afs.collection('donde_comer').ref.where('departamento', \"==\", dpto).get().then(querySnapshot => {\n        const arrRestaurantes = [];\n        querySnapshot.forEach(item => {\n          const data = item.data();\n          arrRestaurantes.push(Object.assign({\n            id: item.id\n          }, data));\n        });\n        this.mapCache.set(dpto, arrRestaurantes.slice());\n        this.restaurantes = arrRestaurantes.slice();\n        this.getRestaurantesFiltrados();\n      }).catch(error => {\n        console.error(\"Error en getEventosFirestore(). error:\" + error);\n      });\n    } else {\n      console.log(\"get restaurantes \" + dpto + \" desde la cache\");\n      this.restaurantes = this.mapCache.get(dpto);\n      this.getRestaurantesFiltrados();\n    }\n  }\n  /**\n   * Función que realiza todos los filtros para restaurantes.\n   * Los filtros se realizan sobre el array local de restaurantes.\n   */\n\n\n  getRestaurantesFiltrados() {\n    // Por departamento\n    if (this.ls.localidad === '' && this.ls.publicado === 'todos') {\n      this.restaurantes$.next(this.restaurantes);\n    } // Departamento y Publidados\n    else if (this.ls.localidad === '' && this.ls.publicado !== 'todos') {\n      let p = this.ls.publicado === 'publicados' ? true : false;\n      this.restaurantes$.next(this.restaurantes.filter(evento => evento.publicado == p));\n    } // Departamento y Localidad \n    else if (this.ls.localidad !== '' && this.ls.publicado === 'todos') {\n      this.restaurantes$.next(this.restaurantes.filter(evento => evento.localidad === this.ls.localidad));\n    } // Departamento, Localidad y Publidados\n    else if (this.ls.localidad !== '' && this.ls.activos === 'todos' && this.ls.publicado !== 'todos') {\n      let p = this.ls.publicado === 'publicados' ? true : false;\n      this.restaurantes$.next(this.restaurantes.filter(evento => evento.localidad === this.ls.localidad && evento.publicado == p));\n    }\n  }\n  /** Obtiene el evento a partir del id que recibe y */\n\n\n  geRestoranId(id) {\n    const restoranEncontrado = this.restaurantes.filter(item => item.id == id);\n    return from(restoranEncontrado);\n  }\n  /**\n   * Agrega un evento en firestore, obteniendo el id resultante para luego insertarlo en el\n   * array local eventos.\n   * @param evento Contiene la información del nuevo evento.\n   * @returns Retorna el ID del evento obtenido de firestore\n   */\n\n\n  addRestoran(restaurant) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      let nuevoId;\n\n      try {\n        const documentRef = yield _this.afs.collection('donde_comer').add(restaurant);\n        nuevoId = documentRef.id;\n        restaurant.id = nuevoId;\n\n        _this.restaurantes.push(restaurant);\n\n        _this.mapCache.set(restaurant.departamento, _this.restaurantes);\n      } catch (error) {\n        console.error(\"Se produjo un error al agregar un nuevo restaurant. Error: \" + error);\n      }\n\n      return new Promise((resolve, reject) => {\n        if (nuevoId !== undefined && nuevoId.length > 0) {\n          resolve(nuevoId);\n        } else {\n          reject(\"No se puedo obtener el ID\");\n        }\n      });\n    })();\n  }\n  /**\n   * Actuliza la información de lugar en la nube de Firestore, utilizando el método destructivo \"set\" (borra todo lo que este y\n   * guarda solo los valores actuales).\n   * @param lugar Contiene todos los datos del lugar menos el ID.\n   * @returns\n   */\n\n\n  updateRestoranFirestore(restaurant, id) {\n    return this.afs.doc(`donde_comer/${id}`).set(restaurant); //en ves de pasar el lugar completo se puede poner campo por campo        \n  }\n  /**\n   * Actualiza la información de un restuarente ya existente en el array local restaurantes.\n   * Y actualiza la cache de restaurantes.\n   * @param data Es la data con toda la información del lugar includio el ID\n   */\n\n\n  updateRestoranLocal(data) {\n    console.log(\"ID: \" + data.id);\n    let i = this.restaurantes.findIndex(restaurant => restaurant.id === data.id);\n    this.restaurantes[i] = JSON.parse(JSON.stringify(data));\n    this.mapCache.set(data.departamento, this.restaurantes);\n  }\n\n  getCache(nombreDpto) {\n    return this.mapCache.get(nombreDpto);\n  }\n  /**\n   * Obtiene el observable del Subject eventos$ con la lista de todos los eventos.\n   * @returns {Observable}\n   */\n\n\n  getObsRestaurantes$() {\n    return this.restaurantes$.asObservable();\n  }\n\n  emitirEventos() {\n    this.restaurantes$.next(this.restaurantes);\n  }\n  /** Elimina correctamente el evento */\n\n\n  deleteRestoran(id) {\n    let indiceEliminar = this.restaurantes.findIndex(item => item.id === id);\n    this.afs.collection('donde_comer').doc(id).delete().then(res => {\n      this.restaurantes.splice(indiceEliminar, 1);\n      this.emitirEventos();\n      console.log(\"Evento eliminado correntamente\");\n    }).catch(err => {\n      console.error(\"Se produjo un error al intentar eliminar un el evento \" + id + \". Error:\" + err);\n    });\n  }\n  /**\n   *  Función para generar string random, se utilizar para crear el nombre de la carpeta\n   * que almacena las imagenes. Funciona como un id.\n   * @param length Es largo que queremos el string.\n   * @returns Retorna un string random.\n   */\n\n\n  randomString(length) {\n    var randomChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    var result = '';\n\n    for (var i = 0; i < length; i++) {\n      result += randomChars.charAt(Math.floor(Math.random() * randomChars.length));\n    }\n\n    return result;\n  }\n\n}\n\nDondeComerService.ɵfac = function DondeComerService_Factory(t) {\n  return new (t || DondeComerService)(i0.ɵɵinject(i1.AngularFirestore), i0.ɵɵinject(i2.LocalStorageService));\n};\n\nDondeComerService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: DondeComerService,\n  factory: DondeComerService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"sources":["/home/administrador/angular/dominga-panel/src/app/donde-comer/services/donde-comer.service.ts"],"names":["BehaviorSubject","from","i0","i1","i2","DondeComerService","constructor","afs","ls","restaurantes","mapCache","Map","departamento","restaurantes$","getRestaurantesFirestore","dpto","has","length","console","log","collection","ref","where","get","then","querySnapshot","arrRestaurantes","forEach","item","data","push","Object","assign","id","set","slice","getRestaurantesFiltrados","catch","error","localidad","publicado","next","p","filter","evento","activos","geRestoranId","restoranEncontrado","addRestoran","restaurant","nuevoId","documentRef","add","Promise","resolve","reject","undefined","updateRestoranFirestore","doc","updateRestoranLocal","i","findIndex","JSON","parse","stringify","getCache","nombreDpto","getObsRestaurantes$","asObservable","emitirEventos","deleteRestoran","indiceEliminar","delete","res","splice","err","randomString","randomChars","result","charAt","Math","floor","random","ɵfac","DondeComerService_Factory","t","ɵɵinject","AngularFirestore","LocalStorageService","ɵprov","ɵɵdefineInjectable","token","factory","providedIn"],"mappings":"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","sourcesContent":["import { BehaviorSubject, from } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/fire/compat/firestore\";\nimport * as i2 from \"../../shared/services/local-storage.service\";\nexport class DondeComerService {\n    constructor(afs, ls) {\n        this.afs = afs;\n        this.ls = ls;\n        this.restaurantes = []; //copia local de todos los restaurantes para trabajar con ella\n        this.mapCache = new Map();\n        this.departamento = \"San José\";\n        this.restaurantes$ = new BehaviorSubject(this.restaurantes);\n    }\n    /**\n     * Obtiene todos los restaurantes desde firestore y los almacena en restaurantes[] para\n     * no estar consultado la base y minimizar el traficio.\n     */\n    getRestaurantesFirestore(dpto) {\n        if (!this.mapCache.has(dpto) || this.restaurantes.length === 0) {\n            console.log(\"get restaurantes \" + dpto + \" desde firestore\");\n            //        this.afs.collection('eventos').ref.where('departamento', \"==\", departament).where('prioridad', \">\", -1).orderBy('prioridad').get().then(\n            this.afs.collection('donde_comer').ref.where('departamento', \"==\", dpto).get().then(querySnapshot => {\n                const arrRestaurantes = [];\n                querySnapshot.forEach(item => {\n                    const data = item.data();\n                    arrRestaurantes.push(Object.assign({ id: item.id }, data));\n                });\n                this.mapCache.set(dpto, arrRestaurantes.slice());\n                this.restaurantes = arrRestaurantes.slice();\n                this.getRestaurantesFiltrados();\n            }).catch(error => {\n                console.error(\"Error en getEventosFirestore(). error:\" + error);\n            });\n        }\n        else {\n            console.log(\"get restaurantes \" + dpto + \" desde la cache\");\n            this.restaurantes = this.mapCache.get(dpto);\n            this.getRestaurantesFiltrados();\n        }\n    }\n    /**\n     * Función que realiza todos los filtros para restaurantes.\n     * Los filtros se realizan sobre el array local de restaurantes.\n     */\n    getRestaurantesFiltrados() {\n        // Por departamento\n        if (this.ls.localidad === '' && this.ls.publicado === 'todos') {\n            this.restaurantes$.next(this.restaurantes);\n        }\n        // Departamento y Publidados\n        else if (this.ls.localidad === '' && this.ls.publicado !== 'todos') {\n            let p = this.ls.publicado === 'publicados' ? true : false;\n            this.restaurantes$.next(this.restaurantes.filter(evento => evento.publicado == p));\n        }\n        // Departamento y Localidad \n        else if (this.ls.localidad !== '' && this.ls.publicado === 'todos') {\n            this.restaurantes$.next(this.restaurantes.filter(evento => evento.localidad === this.ls.localidad));\n        }\n        // Departamento, Localidad y Publidados\n        else if (this.ls.localidad !== '' && this.ls.activos === 'todos' && this.ls.publicado !== 'todos') {\n            let p = this.ls.publicado === 'publicados' ? true : false;\n            this.restaurantes$.next(this.restaurantes.filter(evento => evento.localidad === this.ls.localidad && evento.publicado == p));\n        }\n    }\n    /** Obtiene el evento a partir del id que recibe y */\n    geRestoranId(id) {\n        const restoranEncontrado = this.restaurantes.filter(item => item.id == id);\n        return from(restoranEncontrado);\n    }\n    /**\n     * Agrega un evento en firestore, obteniendo el id resultante para luego insertarlo en el\n     * array local eventos.\n     * @param evento Contiene la información del nuevo evento.\n     * @returns Retorna el ID del evento obtenido de firestore\n     */\n    async addRestoran(restaurant) {\n        let nuevoId;\n        try {\n            const documentRef = await this.afs.collection('donde_comer').add(restaurant);\n            nuevoId = documentRef.id;\n            restaurant.id = nuevoId;\n            this.restaurantes.push(restaurant);\n            this.mapCache.set(restaurant.departamento, this.restaurantes);\n        }\n        catch (error) {\n            console.error(\"Se produjo un error al agregar un nuevo restaurant. Error: \" + error);\n        }\n        return new Promise((resolve, reject) => {\n            if (nuevoId !== undefined && nuevoId.length > 0) {\n                resolve(nuevoId);\n            }\n            else {\n                reject(\"No se puedo obtener el ID\");\n            }\n        });\n    }\n    /**\n     * Actuliza la información de lugar en la nube de Firestore, utilizando el método destructivo \"set\" (borra todo lo que este y\n     * guarda solo los valores actuales).\n     * @param lugar Contiene todos los datos del lugar menos el ID.\n     * @returns\n     */\n    updateRestoranFirestore(restaurant, id) {\n        return this.afs.doc(`donde_comer/${id}`).set(restaurant); //en ves de pasar el lugar completo se puede poner campo por campo        \n    }\n    /**\n     * Actualiza la información de un restuarente ya existente en el array local restaurantes.\n     * Y actualiza la cache de restaurantes.\n     * @param data Es la data con toda la información del lugar includio el ID\n     */\n    updateRestoranLocal(data) {\n        console.log(\"ID: \" + data.id);\n        let i = this.restaurantes.findIndex(restaurant => restaurant.id === data.id);\n        this.restaurantes[i] = JSON.parse(JSON.stringify(data));\n        this.mapCache.set(data.departamento, this.restaurantes);\n    }\n    getCache(nombreDpto) {\n        return this.mapCache.get(nombreDpto);\n    }\n    /**\n     * Obtiene el observable del Subject eventos$ con la lista de todos los eventos.\n     * @returns {Observable}\n     */\n    getObsRestaurantes$() {\n        return this.restaurantes$.asObservable();\n    }\n    emitirEventos() {\n        this.restaurantes$.next(this.restaurantes);\n    }\n    /** Elimina correctamente el evento */\n    deleteRestoran(id) {\n        let indiceEliminar = this.restaurantes.findIndex(item => item.id === id);\n        this.afs.collection('donde_comer').doc(id).delete().then(res => {\n            this.restaurantes.splice(indiceEliminar, 1);\n            this.emitirEventos();\n            console.log(\"Evento eliminado correntamente\");\n        }).catch(err => {\n            console.error(\"Se produjo un error al intentar eliminar un el evento \" + id + \". Error:\" + err);\n        });\n    }\n    /**\n     *  Función para generar string random, se utilizar para crear el nombre de la carpeta\n     * que almacena las imagenes. Funciona como un id.\n     * @param length Es largo que queremos el string.\n     * @returns Retorna un string random.\n     */\n    randomString(length) {\n        var randomChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n        var result = '';\n        for (var i = 0; i < length; i++) {\n            result += randomChars.charAt(Math.floor(Math.random() * randomChars.length));\n        }\n        return result;\n    }\n}\nDondeComerService.ɵfac = function DondeComerService_Factory(t) { return new (t || DondeComerService)(i0.ɵɵinject(i1.AngularFirestore), i0.ɵɵinject(i2.LocalStorageService)); };\nDondeComerService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: DondeComerService, factory: DondeComerService.ɵfac, providedIn: 'root' });\n"]},"metadata":{},"sourceType":"module"}
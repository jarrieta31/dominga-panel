{"ast":null,"code":"import _asyncToGenerator from \"/home/administrador/angular/dominga-panel/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { BehaviorSubject, from } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/fire/compat/firestore\";\nimport * as i2 from \"../../shared/services/local-storage.service\";\nexport class CarruselesService {\n  constructor(afs, ls) {\n    this.afs = afs;\n    this.ls = ls;\n    this.sliders = []; //copia local de todos los sliders para trabajar con ella\n\n    this.mapCache = new Map();\n    this.slidersRef = this.afs.collection('sliders');\n    this.pantallas = [{\n      name: \"Donde Comer\"\n    }, {\n      name: \"Donde Dormir\"\n    }, {\n      name: \"Informacion\"\n    }, {\n      name: \"Artistas\"\n    }, {\n      name: \"Eventos\"\n    }, {\n      name: \"Lugares\"\n    }];\n    this.sliders$ = new BehaviorSubject(this.sliders);\n  }\n  /**\n   * Obtiene todos los sliders desde firestore y los almacena en sliders[] para\n   * no estar consultado la base y minimizar el traficio.\n   */\n\n\n  getSliderFirestore(pantalla) {\n    console.log(this.sliders.length);\n\n    if (!this.mapCache.has(pantalla) || this.sliders.length === 0) {\n      console.log(\"get sliders desde firestore\");\n      this.slidersRef.ref.where('pantalla', '==', pantalla).get().then(querySnapshot => {\n        const arrSliders = [];\n        querySnapshot.forEach(item => {\n          const data = item.data();\n          arrSliders.push(Object.assign({\n            id: item.id\n          }, data));\n        });\n        this.mapCache.set(pantalla, arrSliders.slice());\n        this.sliders = arrSliders.slice();\n        this.sliders$.next(this.sliders); //this.getRestaurantesFiltrados()\n      }).catch(error => {\n        console.error(\"Error en getSlidersFirestore(). error:\" + error);\n      });\n    } else {\n      console.log(\"get sliders desde la cache\");\n      this.sliders = this.mapCache.get(pantalla);\n      this.sliders$.next(this.sliders); //this.getSlidersFiltrados();\n    }\n  }\n  /**\n   * Función que realiza todos los filtros para sliders.\n   * Los filtros se realizan sobre el array local de sliders.\n   */\n\n\n  getRestaurantesFiltrados() {}\n  /** Obtiene el slider a partir del id que recibe y */\n\n\n  getSliderId(id) {\n    const restoranEncontrado = this.sliders.filter(item => item.id == id);\n    return from(restoranEncontrado);\n  }\n  /**\n   * Agrega un slider en firestore, obteniendo el id resultante para luego insertarlo en el\n   * array local sliders.\n   * @param slider Contiene la información del nuevo slider.\n   * @returns Retorna el ID del slider obtenido de firestore\n   */\n\n\n  addSlider(slider) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      let nuevoId;\n\n      try {\n        const documentRef = yield _this.slidersRef.add(slider);\n        nuevoId = documentRef.id;\n        slider.id = nuevoId;\n\n        _this.sliders.push(slider);\n\n        _this.mapCache.set(slider.pantalla, _this.sliders);\n      } catch (error) {\n        console.error(\"Se produjo un error al agregar un nuevo slider. Error: \" + error);\n      }\n\n      return new Promise((resolve, reject) => {\n        if (nuevoId !== undefined && nuevoId.length > 0) {\n          resolve(nuevoId);\n        } else {\n          reject(\"No se puedo obtener el ID\");\n        }\n      });\n    })();\n  }\n  /**\n   * Actuliza la información de lugar en la nube de Firestore, utilizando el método destructivo \"set\" (borra todo lo que este y\n   * guarda solo los valores actuales).\n   * @param lugar Contiene todos los datos del lugar menos el ID.\n   * @returns\n   */\n\n\n  updateSliderFirestore(slider, id) {\n    return this.afs.doc(`sliders/${id}`).set(slider); //en ves de pasar el lugar completo se puede poner campo por campo        \n  }\n  /**\n   * Actualiza la información de un restuarente ya existente en el array local sliders.\n   * Y actualiza la cache de sliders.\n   * @param data Es la data con toda la información del lugar includio el ID\n   */\n\n\n  updateSliderLocal(data) {\n    let i = this.sliders.findIndex(slider => slider.id === data.id);\n\n    if (i !== -1) {\n      this.sliders[i] = JSON.parse(JSON.stringify(data));\n      this.mapCache.set(data.pantalla, this.sliders);\n    }\n\n    this.getSliderFirestore(data.pantalla);\n  }\n  /**\n   * Obtiene el observable del Subject sliders$ con la lista de todos los sliders.\n   * @returns {Observable}\n   */\n\n\n  getObsSliders$() {\n    return this.sliders$.asObservable();\n  }\n\n  emitirSliders() {\n    this.sliders$.next(this.sliders);\n  }\n  /** Elimina correctamente el slider */\n\n\n  deleteSlider(id) {\n    let indiceEliminar = this.sliders.findIndex(item => item.id === id);\n    this.slidersRef.doc(id).delete().then(res => {\n      this.sliders.splice(indiceEliminar, 1);\n      this.emitirSliders();\n      console.log(\"Slider eliminado correntamente\");\n    }).catch(err => {\n      console.error(\"Se produjo un error al intentar eliminar un el slider \" + id + \". Error:\" + err);\n    });\n  }\n  /**\n   *  Función para generar string random, se utilizar para crear el nombre de la carpeta\n   * que almacena las imagenes. Funciona como un id.\n   * @param length Es largo que queremos el string.\n   * @returns Retorna un string random.\n   */\n\n\n  randomString(length) {\n    var randomChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    var result = '';\n\n    for (var i = 0; i < length; i++) {\n      result += randomChars.charAt(Math.floor(Math.random() * randomChars.length));\n    }\n\n    return result;\n  }\n\n}\n\nCarruselesService.ɵfac = function CarruselesService_Factory(t) {\n  return new (t || CarruselesService)(i0.ɵɵinject(i1.AngularFirestore), i0.ɵɵinject(i2.LocalStorageService));\n};\n\nCarruselesService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: CarruselesService,\n  factory: CarruselesService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"sources":["/home/administrador/angular/dominga-panel/src/app/carruseles/services/carruseles.service.ts"],"names":["BehaviorSubject","from","i0","i1","i2","CarruselesService","constructor","afs","ls","sliders","mapCache","Map","slidersRef","collection","pantallas","name","sliders$","getSliderFirestore","pantalla","console","log","length","has","ref","where","get","then","querySnapshot","arrSliders","forEach","item","data","push","Object","assign","id","set","slice","next","catch","error","getRestaurantesFiltrados","getSliderId","restoranEncontrado","filter","addSlider","slider","nuevoId","documentRef","add","Promise","resolve","reject","undefined","updateSliderFirestore","doc","updateSliderLocal","i","findIndex","JSON","parse","stringify","getObsSliders$","asObservable","emitirSliders","deleteSlider","indiceEliminar","delete","res","splice","err","randomString","randomChars","result","charAt","Math","floor","random","ɵfac","CarruselesService_Factory","t","ɵɵinject","AngularFirestore","LocalStorageService","ɵprov","ɵɵdefineInjectable","token","factory","providedIn"],"mappings":"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","sourcesContent":["import { BehaviorSubject, from } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/fire/compat/firestore\";\nimport * as i2 from \"../../shared/services/local-storage.service\";\nexport class CarruselesService {\n    constructor(afs, ls) {\n        this.afs = afs;\n        this.ls = ls;\n        this.sliders = []; //copia local de todos los sliders para trabajar con ella\n        this.mapCache = new Map();\n        this.slidersRef = this.afs.collection('sliders');\n        this.pantallas = [\n            { name: \"Donde Comer\" },\n            { name: \"Donde Dormir\" },\n            { name: \"Informacion\" },\n            { name: \"Artistas\" },\n            { name: \"Eventos\" },\n            { name: \"Lugares\" },\n        ];\n        this.sliders$ = new BehaviorSubject(this.sliders);\n    }\n    /**\n     * Obtiene todos los sliders desde firestore y los almacena en sliders[] para\n     * no estar consultado la base y minimizar el traficio.\n     */\n    getSliderFirestore(pantalla) {\n        console.log(this.sliders.length);\n        if (!this.mapCache.has(pantalla) || this.sliders.length === 0) {\n            console.log(\"get sliders desde firestore\");\n            this.slidersRef.ref.where('pantalla', '==', pantalla).get().then(querySnapshot => {\n                const arrSliders = [];\n                querySnapshot.forEach(item => {\n                    const data = item.data();\n                    arrSliders.push(Object.assign({ id: item.id }, data));\n                });\n                this.mapCache.set(pantalla, arrSliders.slice());\n                this.sliders = arrSliders.slice();\n                this.sliders$.next(this.sliders);\n                //this.getRestaurantesFiltrados()\n            }).catch(error => {\n                console.error(\"Error en getSlidersFirestore(). error:\" + error);\n            });\n        }\n        else {\n            console.log(\"get sliders desde la cache\");\n            this.sliders = this.mapCache.get(pantalla);\n            this.sliders$.next(this.sliders);\n            //this.getSlidersFiltrados();\n        }\n    }\n    /**\n     * Función que realiza todos los filtros para sliders.\n     * Los filtros se realizan sobre el array local de sliders.\n     */\n    getRestaurantesFiltrados() {\n    }\n    /** Obtiene el slider a partir del id que recibe y */\n    getSliderId(id) {\n        const restoranEncontrado = this.sliders.filter(item => item.id == id);\n        return from(restoranEncontrado);\n    }\n    /**\n     * Agrega un slider en firestore, obteniendo el id resultante para luego insertarlo en el\n     * array local sliders.\n     * @param slider Contiene la información del nuevo slider.\n     * @returns Retorna el ID del slider obtenido de firestore\n     */\n    async addSlider(slider) {\n        let nuevoId;\n        try {\n            const documentRef = await this.slidersRef.add(slider);\n            nuevoId = documentRef.id;\n            slider.id = nuevoId;\n            this.sliders.push(slider);\n            this.mapCache.set(slider.pantalla, this.sliders);\n        }\n        catch (error) {\n            console.error(\"Se produjo un error al agregar un nuevo slider. Error: \" + error);\n        }\n        return new Promise((resolve, reject) => {\n            if (nuevoId !== undefined && nuevoId.length > 0) {\n                resolve(nuevoId);\n            }\n            else {\n                reject(\"No se puedo obtener el ID\");\n            }\n        });\n    }\n    /**\n     * Actuliza la información de lugar en la nube de Firestore, utilizando el método destructivo \"set\" (borra todo lo que este y\n     * guarda solo los valores actuales).\n     * @param lugar Contiene todos los datos del lugar menos el ID.\n     * @returns\n     */\n    updateSliderFirestore(slider, id) {\n        return this.afs.doc(`sliders/${id}`).set(slider); //en ves de pasar el lugar completo se puede poner campo por campo        \n    }\n    /**\n     * Actualiza la información de un restuarente ya existente en el array local sliders.\n     * Y actualiza la cache de sliders.\n     * @param data Es la data con toda la información del lugar includio el ID\n     */\n    updateSliderLocal(data) {\n        let i = this.sliders.findIndex(slider => slider.id === data.id);\n        if (i !== -1) {\n            this.sliders[i] = JSON.parse(JSON.stringify(data));\n            this.mapCache.set(data.pantalla, this.sliders);\n        }\n        this.getSliderFirestore(data.pantalla);\n    }\n    /**\n     * Obtiene el observable del Subject sliders$ con la lista de todos los sliders.\n     * @returns {Observable}\n     */\n    getObsSliders$() {\n        return this.sliders$.asObservable();\n    }\n    emitirSliders() {\n        this.sliders$.next(this.sliders);\n    }\n    /** Elimina correctamente el slider */\n    deleteSlider(id) {\n        let indiceEliminar = this.sliders.findIndex(item => item.id === id);\n        this.slidersRef.doc(id).delete().then(res => {\n            this.sliders.splice(indiceEliminar, 1);\n            this.emitirSliders();\n            console.log(\"Slider eliminado correntamente\");\n        }).catch(err => {\n            console.error(\"Se produjo un error al intentar eliminar un el slider \" + id + \". Error:\" + err);\n        });\n    }\n    /**\n     *  Función para generar string random, se utilizar para crear el nombre de la carpeta\n     * que almacena las imagenes. Funciona como un id.\n     * @param length Es largo que queremos el string.\n     * @returns Retorna un string random.\n     */\n    randomString(length) {\n        var randomChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n        var result = '';\n        for (var i = 0; i < length; i++) {\n            result += randomChars.charAt(Math.floor(Math.random() * randomChars.length));\n        }\n        return result;\n    }\n}\nCarruselesService.ɵfac = function CarruselesService_Factory(t) { return new (t || CarruselesService)(i0.ɵɵinject(i1.AngularFirestore), i0.ɵɵinject(i2.LocalStorageService)); };\nCarruselesService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: CarruselesService, factory: CarruselesService.ɵfac, providedIn: 'root' });\n"]},"metadata":{},"sourceType":"module"}